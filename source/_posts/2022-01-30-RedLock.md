---
layout: post
title: RedLock
tag: 技术笔记
date: 2022-2-1
category: Technology
---

#### 首先引入需要锁的条件

1. 多任务环境下（进程或者线程）；
2. 任务都对同一共享资源进行读写；

1. 对资源的访问应该是互斥的。

但如果是分布式环境的话，JVM锁，是解决不了环境加锁的问题的。

按照官方的思路语设计方案，算法只需具备3个特性就可以实现一个最低保障的分布式锁：

1. 安全属性（Safety property）：独享（相互排斥）。在任意一个时刻，只有一个客户端持有锁；
2. 活性A（Liveness property A）：无死锁，即便持有锁的客户端崩溃，或者网络被分裂，锁任然可以被获取；

1. 活性B（Liveness property B）：容错，只要大部分Redis节点都活着，客户端就可以获取和释放锁。

#### 主从分布式锁的问题

实现Redis分布式锁的最简单的方式就是在Redis中创建一个key，这个key有一个失效时间（TTL），以保证锁最终会被自动释放掉。或者当客户端释放资源（业务主动解锁），会删除掉这个key。（注意其原子性）

```lua
SET key_name my_random_value NX PX 30000
```

这个命令仅在不存在key的时候才能被执行成功（NX选项），并且有一个30秒的自动失效时间（PX属性）。这个key的值是一个随机值（my_random_value），当然这个值在所有的客户端必须是唯一的，所有同一key的获取者，这个值都不能一样。

在获取锁后，并完成相关业务后，需要删除自己设置的锁，保证服务器资源的高利用效率，不用等到锁自动过期才删除.

```lua
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
```

从表面上看似乎效果不错，的那有一个严重的单点失败问题，如果当前你加锁的Redis节点挂怎么办？就算是主从架构，但是要记住，	Redis是不能实现资源共享的，因为其主从同步也是异步的，就会有下面这种情况出现：

1. 客户端A从master上获取到锁
2. 在master将锁同步slave之前，master挂了

1. slave升级为master节点
2. 锁丢失，安全失效

#### RedLock算法

在Redis的分布式环境中，我们假设有N个Redis master。这些节点是完全互相独立的，不存在主从复制或者其他集群协调机制。之前讲过了如何在Redis单示例下怎么安全地获取和释放锁，我们确保将在每个实例上使用此方法获取和释放锁，在这个样例中，假设N为5，既有5个Redis master节点，我们可以在5台机器上面或者5台虚拟机上面运行这些实例，这样保证他们不会同时都宕掉。为了取到锁，客户端应该执行以下操作：

1.  获取当前Unix时间，以毫秒为为单位；
2. 依次尝试N个实例，使用相同的key和随机值获取锁，在步骤2，当向Redis设置锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应该远远小于锁的失效时间。这样可以避免服务端Redis已经挂掉的情况下，客户端还在死死的等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试另外一个Redis实例；

1. 客户端使用当前时间减去开始获取锁时间，就得到获取所使用的时间；
2. 如果去到了锁，key真正的有效时间等于有效时间减去获取锁使用的时间；

1. 如果因为某些原因，获取锁失败（没有在至少N/2 + 1个Redis实例获取到锁，或者获取所得时间已经超过了有效时间），客户端应该在所有的Redis实例上进行解锁。

**一些注意点**

先假设client获取所有实例，所有实例包含相同的key或过期时间（TTL），但每个实例set命令时间不同导致不能同时过期，第一个set命令之前是T1，最后一个set命令后的时间为T2，则此client有效获取锁的最小时间为TTL-（T2-T1）- 时钟漂移；

对于以N/2 + 1，也就是一半以上的方式判断取锁成功，是因为如果小于一半判断为成功的话，有可能出现多个client都成果获取锁的情况，从而使锁失效

一个client锁定大多数事例耗费的时间大于或接近锁的过期时间，就认为锁无效，并且解锁这个redis实例；只要在TTL时间内成功获取一半以上的锁便是有效锁，否则无效。

如果redis没有持久化功能，在clientA获取锁成功后，所有redis重启，clientB能够再次获取到锁，这样违法了锁的排他互斥性；如果启动AOF永久化存储，事情会好些， 举例:当我们重启redis后，由于redis过期机制是按照unix时间戳走的，所以在重启后，然后会按照规定的时间过期，不影响业务;但是由于AOF同步到磁盘的方式默认是每秒-次，如果在一秒内断电，会导致数据丢失，立即重启会造成锁互斥性失效;但如果同步磁盘方式使用Always(每一个写命令都同步到硬盘)造成性能急剧下降;所以在锁完全有效性和性能方面要有所取舍；有效解决既保证锁完全有效性及性能高效及即使断电情况的方法是redis同步到磁盘方式保持默认的每秒，在redis无论因为什么原因停掉后要等待TTL时间后再重启(学名:**延迟重启**) ;缺点是 在TTL时间内服务相当于暂停状态;

**总结**

1.TTL时长 要大于正常业务执行的时间+获取所有redis服务消耗时间+时钟漂移

2.获取redis所有服务消耗时间要 远小于TTL时间，并且获取成功的锁个数要 在总数的一般以上:N/2+1

3.尝试获取每个redis实例锁时的时间要 远小于TTL时间

4.尝试获取所有锁失败后 重新尝试一定要有一定次数限制

5.在redis崩溃后（无论一个还是所有），要延迟TTL时间重启redis

6.在实现多redis节点时要结合单节点分布式锁算法 共同实现