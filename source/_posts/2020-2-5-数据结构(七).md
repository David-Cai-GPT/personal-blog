---
layout: post
title: 数据结构学习(七)！
tag: 数据结构
date: 2020-2-5
category: Technology blog
---

# **二叉树**

​    二叉树是每个节点最多有两个子树的树结构。通常子树称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找和二叉堆。

​    **定义：**二叉树是一个连通的无环图，并且每一个顶点的度不大于3.有根二叉树还要满足根结点的度不大于2.有了根结点之后，每个顶点定义了唯一的父节点，和最多2个子结点。

​    **完全二叉树：**除二叉树最后一层叶结点没有子结点以外，其他各层的结点数都达到最大个数，并且叶结点都是从左到右依次排布，这就是完全二叉树。

​    **满二叉树：**除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树。

​    **平衡二叉树：**平衡二叉树又被称为AVL树，它是一棵二叉排序树，且具有以下性质，它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

## **二叉树实现**

```java


public class Demo02 {
	public static class BinaryTreeNode{
		public int getData() {
			return data;
		}
		public void setData(int data) {
			this.data = data;
		}
		public BinaryTreeNode getLeftChild() {
			return leftChild;
		}
		public void setLeftChild(BinaryTreeNode leftChild) {
			this.leftChild = leftChild;
		}
		public BinaryTreeNode getRightChild() {
			return rightChild;
		}
		public void setRightChild(BinaryTreeNode rightChild) {
			this.rightChild = rightChild;
		}
		private int data;
		private BinaryTreeNode leftChild;
		private BinaryTreeNode rightChild;
	
	public  BinaryTreeNode(int data, BinaryTreeNode leftChild,BinaryTreeNode rightChild) {
		super();
		this.data = data;
		this.leftChild = leftChild;
		this.rightChild = rightChild;
	}
	}
	public static void main(String[] args) {
		BinaryTreeNode node10 = new BinaryTreeNode(10,null,null);
		BinaryTreeNode node9 = new BinaryTreeNode(9,null,null);
		BinaryTreeNode node8 = new BinaryTreeNode(8,null,null);
		BinaryTreeNode node7 = new BinaryTreeNode(7,null,null);
		BinaryTreeNode node6= new BinaryTreeNode(6,null,null);
		BinaryTreeNode node5 = new BinaryTreeNode(5,node10,null);
		BinaryTreeNode node4 = new BinaryTreeNode(4,node8,node9);
		BinaryTreeNode node3= new BinaryTreeNode(3,node6,node7);
		BinaryTreeNode node2 = new BinaryTreeNode(2,node4,node5);
		BinaryTreeNode node1 = new BinaryTreeNode(1,node2,node3);
	}



```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

​    **遍历**是对树的一种最基本的运算，所谓遍历二叉树，就是按一定的规则和顺序走遍二叉树的所有结点，是每一个结点都被访问一次，而且只被访问一次，由于二叉树是非线性结构，因此，树的遍历实质上是将二叉树的各个节点转换成为一个线性序列来表示

## **前序遍历（先序遍历）**

首先访问根，在先序遍历左子树，最后先序遍历右

```java
public void preOrder(BinaryTreeNode root) {
			if(null != root) {
				System.out.println(root.getData());
				preOrder(root.getLeftChild());
				preOrder(root.getRightChild());
			}
		}
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

![img](https://img-blog.csdnimg.cn/20190325091227702.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDQzOTA4NQ==,size_16,color_FFFFFF,t_70)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

##  **中序遍历**

首先中序遍历左子树，在访问根，最后中序遍历右子树。

```java
	public void inOrder(BinaryTreeNode root) {
			if(root != null) {
				inOrder(root.getLeftChild());
				System.out.println(root.getData()+ "\t");
				inOrder(root.getRightChild());
			}
		}
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)



**![img](https://img-blog.csdnimg.cn/20190325091701498.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDQzOTA4NQ==,size_16,color_FFFFFF,t_70)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)**

##  **后序遍历**

首先后序遍历左子树，在后续遍历右子树，最后访问根。

```java
	public void postOrder(BinaryTreeNode root) {
			if(root != null) {
				postOrder(root.getLeftChild());
				postOrder(root.getRightChild());
				System.out.println(root.getData()+ "\t");
			}
		}
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

![img](https://img-blog.csdnimg.cn/20190325092335360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDQzOTA4NQ==,size_16,color_FFFFFF,t_70)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)